# RTE-Group

## Описание проекта

## Реализованный функционал

## Используемые технологии

### 1. Normlize.css

[Normlize.css](https://necolas.github.io/normalize.css/) — это небольшая библиотека, которая предназначена для создания единообразной базовой стилизации для веб-страниц. Основная цель `normalize.css` - это сделать стандартные стили элементов `HTML` более предсказуемыми и унифицированными между разными браузерами.

Вот краткая информация о `normalize.css`:

1. **Сброс стандартных стилей браузера**: `normalize.css` предоставляет набор стилей, который аннулирует или сбрасывает стандартные стили браузера, такие как отступы, маржи, шрифты и др. Это помогает установить начальное состояние элементов `HTML` на более предсказуемое значение.

2. **Унификация стилей**: `normalize.css` стандартизирует стили элементов `HTML`, делая их более согласованными между разными браузерами. Это уменьшает различия в отображении веб-страниц и упрощает жизнь разработчикам.

3. **Основан на исследованиях**: Библиотека `normalize.css` разрабатывается на основе исследований и анализа стандартных стилей браузеров. Это означает, что она учитывает различные особенности и баги браузеров.

4. **Легковесность**: `normalize.css` является относительно легкой библиотекой и не включает в себя избыточные стили. Это позволяет вам добавлять собственные стили, не перекрывая её.

5. **Использование**: Чтобы использовать `normalize.css`, вы просто должны подключить её в вашем проекте, обычно в виде ссылки на внешний файл `CSS`. После этого она будет применяться ко всем элементам на вашей странице.

Существует несколько способов установить `normalize.css`. Один из самых простых - использовать пакетный менеджер `npm`:

```bash
npm install normalize.css
```

Эта команда установит `normalize.css` в ваш проект как зависимость разработки.

Использование:

```sass
<!-- index.scss -->
@import url('normalize.css');
```

### 2. ESLint

[ESLint](https://eslint.org/) - это инструмент для статического анализа кода в `JavaScript`. Он помогает выявлять потенциальные проблемы и ошибки в коде, а также обеспечивает согласованность стиля кодирования в команде разработчиков.

Вот краткая информация о `ESLint`:

1. **Статический анализ**: `ESLint` проверяет код без его выполнения, выявляя потенциальные ошибки, несоответствия стандартам и другие проблемы.

2. **Поддержка разных стандартов**: `ESLint` позволяет настраивать правила и стандарты кодирования под конкретные требования проекта или команды разработчиков. Существует множество предустановленных конфигураций, таких как `airbnb`, `standard`, `google`, и другие.

3. **Интеграция в среду разработки**: `ESLint` может быть интегрирован в различные среды разработки и редакторы кода. Есть плагины для `VS Code`, `Sublime Text`, `Atom`, и других популярных редакторов.

4. **Автоматические исправления**: `ESLint` может автоматически исправлять некоторые типы ошибок, что упрощает поддержку чистого и согласованного кода.

5. **Поддержка `ECMAScript 6` и выше**: `ESLint` полностью поддерживает новые возможности `JavaScript`, включая `ECMAScript` 6, 7, и т.д.

6. **Плагины и расширяемость**: Вы можете расширить функциональность `ESLint` с помощью плагинов для проверки специфических типов файлов или использования специфических библиотек.

7. **Интеграция с CI/CD**: `ESLint` может быть интегрирован в процессы непрерывной интеграции (`CI`) и непрерывной доставки (`CD`), позволяя автоматизировать проверку кода перед его развертыванием.

Установка и настройка `ESLint` позволяет разработчикам поддерживать высокое качество кода, предотвращать ошибки и улучшать читаемость кода в командном проекте.

Существует несколько способов установить `ESLint`. Один из самых простых - использовать пакетный менеджер `npm`:

```bash
npm install eslint --save-dev
```

Эта команда установит `ESLint` в ваш проект как зависимость разработки.

Файл конфигурации для `ESLint`:

```js
// .eslintrc.js
module.exports = {
  env: {
    browser: true,
    node: true,
    es2021: true,
  },
  extends: "eslint:recommended",
  parserOptions: {
    ecmaVersion: 12,
    sourceType: "module",
  },
  rules: {
    indent: ["error", 2],
    quotes: ["error", "single"],
    semi: ["error", "always"],
  },
};
```

1. `env`: Устанавливает окружения, для которых применяются правила. В данном случае указаны `browser` (браузерное окружение), `node` (среда выполнения `Node.js`) и `es2021` (поддержка `ECMAScript 2021`).

2. `extends`: Используемый набор правил. В данном случае используется предустановленный набор правил `'eslint:recommended'`, который включает базовые правила для обеспечения чистоты кода.

3. `parserOptions`: Настройки для парсера. В данном случае указаны версия `ECMAScript` (`ecmaVersion`) и тип источника (`sourceType`). Версия `ECMAScript 12` соответствует `ECMAScript 2021`.

4. `rules`: Определяет индивидуальные правила `ESLint`. Каждое правило указывается в формате `[ключ, значение]`. Например, `indent` указывает, что нужно использовать `2` пробела для отступов, quotes требует использовать одинарные кавычки для строк, а `semi` указывает, что точки с запятой должны присутствовать в конце каждого выражения.

Этот конфигурационный файл позволяет проверять код на соответствие основным правилам стандарта `ESLint`, таким как отступы, использование кавычек и точек с запятой. Он также определяет окружения, в которых может выполняться ваш код.

### 3. Prettier

[Prettier](https://prettier.io/) - это инструмент для форматирования кода, который автоматизирует процесс выравнивания и стилизации вашего исходного кода. Он помогает поддерживать единообразный и читаемый стиль кодирования в команде разработчиков.

Вот краткая информация о `Prettier`:

1. **Автоматическое форматирование**: `Prettier` анализирует ваш код и автоматически приводит его в соответствие с набором заданных правил форматирования.

2. **Поддержка разных языков**: `Prettier` поддерживает не только `JavaScript`, но и множество других языков, таких как `HTML`, `CSS`, `JSON`, `YAML`, `Markdown` и др.

3. **Интеграция с редакторами кода**: Существуют плагины `Prettier` для большинства популярных редакторов кода, что позволяет автоматически форматировать код при сохранении файла.

4. **Интеграция с инструментами сборки**: `Prettier` может быть интегрирован в ваши сборочные процессы, что позволяет автоматически форматировать весь ваш проект.

5. **Простота конфигурации**: В отличие от многих других инструментов форматирования, `Prettier` имеет минимальные настройки по умолчанию и не требует долгой конфигурации.

6. **Сохранение времени и улучшение читаемости**: Благодаря автоматическому форматированию, разработчики экономят время на ручной стилизации кода и могут сосредотачиваться на написании логики.

7. **Обратная совместимость с `ESLint` и другими инструментами**: `Prettier` может быть использован вместе с другими инструментами статического анализа, такими как `ESLint`, для обеспечения полного покрытия проверок.

Использование `Prettier` помогает поддерживать чистоту и единообразие в коде, что улучшает его читаемость и облегчает совместную работу в команде разработчиков.

Существует несколько способов установить `Prettier`. Один из самых простых - использовать пакетный менеджер `npm`:

```bash
npm install prettier --save-dev
```

Эта команда установит `Prettier` в ваш проект как зависимость разработки.

Файл конфигурации для `Prettier`:

```json
// prettierrc.json
{
  "trailingComma": "es5",
  "tabWidth": 2,
  "semi": false,
  "singleQuote": true,
  "jsxSingleQuote": true,
  "arrowParens": "always",
  "useTabs": false
}
```

1. `trailingComma`: Указывает, нужно ли добавлять запятые в конце элементов в массивах и объектах. Здесь установлено значение `"es5"`, что означает добавление запятых только для массивов и объектов в стандарте `ECMAScript 5` и выше.

2. `tabWidth`: Устанавливает ширину отступов. В этом случае установлено значение `2`, что означает, что каждый уровень отступа будет состоять из двух пробелов.

3. `semi`: Указывает, нужно ли добавлять точки с запятой в конце выражений. Здесь установлено значение `false`, что означает отключение автоматического добавления точек с запятой.

4. `singleQuote`: Указывает, следует ли использовать одинарные кавычки вместо двойных для строк. Здесь установлено значение `true`, что означает использование одинарных кавычек.

5. `jsxSingleQuote`: Указывает, следует ли использовать одинарные кавычки в `JSX-коде`. Здесь установлено значение true, что означает использование одинарных кавычек.

6. `arrowParens`: Указывает, нужно ли добавлять круглые скобки вокруг единственного параметра стрелочной функции. Здесь установлено значение `"always"`, что означает, что всегда должны быть круглые скобки.

7. `useTabs`: Указывает, следует ли использовать символы табуляции вместо пробелов для отступов. Здесь установлено значение `false`, что означает использование пробелов.

Эти параметры помогают задать консистентный и предпочтительный стиль форматирования для вашего кода. `Prettier` будет автоматически применять эти правила при форматировании вашего кода.

### 4. Stylelint

[Stylelint](https://stylelint.io/) - это инструмент для проверки и форматирования кода в файлах со стилями, таких как `CSS` и его расширения (например, `SCSS`, `Less`). Он помогает поддерживать стиль кодирования в соответствии с установленными правилами и стандартами.

Вот краткая информация о `Stylelint`:

1. **Проверка стилей**: `Stylelint` анализирует файлы со стилями и выявляет нарушения установленных правил форматирования.

2. **Конфигурационные файлы**: Вы можете создать файл конфигурации для `Stylelint` (например, `.stylelintrc.js`), в котором определите правила проверки и форматирования.

3. **Расширяемость**: `Stylelint` можно расширить с помощью плагинов и конфигураций, что позволяет настраивать инструмент под свои нужды.

4. **Интеграция с редакторами кода**: Многие редакторы кода поддерживают интеграцию с `Stylelint`, что позволяет получать уведомления о нарушениях правил прямо в редакторе.

5. **Поддержка различных стандартов**: `Stylelint` имеет различные предустановленные конфигурации, такие как `stylelint-config-standard`, которые включают наборы правил, соответствующих стандартам написания кода.

6. **Поддержка различных препроцессоров**: `Stylelint` понимает синтаксис SCSS, Less и других препроцессоров, что позволяет анализировать файлы с расширениями этих языков.

7. **Подсветка ошибок и предупреждений**: `Stylelint` выделяет строки с нарушениями правил, делая их легко обнаружимыми и исправляемыми.

8. **Интеграция в сборочные процессы**: `Stylelint` можно интегрировать в процессы сборки проекта, чтобы автоматически проверять код перед его развертыванием.

Использование `Stylelint` помогает поддерживать код в чистом, читаемом и согласованном состоянии, что важно для командной разработки и обеспечивает высокое качество кода.

Существует несколько способов установить `Stylelint`. Один из самых простых - использовать пакетный менеджер `npm`:

```bash
npm install stylelint stylelint-config-standard --save-dev
```

Эта команда установит `Stylelint` и стандартную конфигурацию в ваш проект как зависимость разработки.

Файл конфигурации для `Stylelint`:

```json
// .stylelintrc.json
{
  "extends": "stylelint-config-standard",
  "rules": {
    "block-no-empty": null,
    "selector-class-pattern": null,
    "at-rule-no-unknown": [
      true,
      {
        "ignoreAtRules": ["mixin", "include", "if", "use"]
      }
    ]
  }
}
```

1. `extends`: `"stylelint-config-standard"`: Указывает, что этот конфигурационный файл расширяет стандартную конфигурацию `Stylelint`. Таким образом, он наследует набор правил из этой стандартной конфигурации.

2. `rules`: Этот блок содержит набор правил для проверки стилей. Каждый ключ в этом блоке представляет собой название правила, а значение - его настройки.

3. `block-no-empty`: `null`: Это правило проверяет, что блоки (например, селекторы) не являются пустыми. В данной конфигурации оно отключено (`null`), что означает, что правило не применяется.

4. `selector-class-pattern`: `null`: Это правило позволяет указать собственный паттерн для названий классов. В данной конфигурации оно также отключено.

5. `at-rule-no-unknown`: Это правило проверяет, что все `at-правила` (например, `@media`, `@font-face`) являются известными. Здесь установлено значение `true`, что означает, что правило активно. В блоке `ignoreAtRules` перечислены `at-правила`, которые не будут проверяться этим правилом.

6. `ignoreAtRules`: `["mixin", "include", "if", "use"]`: Здесь перечислены четыре at-правила (`@mixin`, `@include`, `@if`, `@use`), которые будут игнорироваться при проверке.

Эти настройки позволяют подстроить проверку стилей под особенности вашего проекта и вашего командного стиля написания кода.

### 5. HTMLHint

[HTMLHint](https://htmlhint.com/) - это инструмент для статического анализа `HTML-кода` с целью выявления потенциальных проблем и ошибок в разметке веб-страницы.

Вот краткая информация о `HTMLHint`:

1. **Проверка структуры `HTML`**: `HTMLHint` проверяет корректность структуры `HTML-кода`, включая правильное вложение тегов, наличие обязательных атрибутов и т.д.

2. **Конфигурационные файлы**: Как и в случае с другими линтерами, `HTMLHint` позволяет создавать файлы конфигурации (например, `.htmlhintrc`), в которых определяются правила проверки.

3. **Настраиваемость**: `HTMLHint` позволяет настраивать набор правил с учетом особенностей проекта.

4. **Интеграция с редакторами кода**: Многие редакторы кода поддерживают интеграцию с `HTMLHint`, что позволяет получать уведомления о нарушениях правил прямо в редакторе.

5. **Подсветка ошибок и предупреждений**: `HTMLHint` выделяет строки с нарушениями правил, делая их легко обнаружимыми и исправляемыми.

6. **Интеграция в сборочные процессы**: `HTMLHint` можно интегрировать в процессы сборки проекта, чтобы автоматически проверять код перед его развертыванием.

Использование `HTMLHint` помогает поддерживать чистоту и корректность `HTML-кода`, что важно для обеспечения хорошей доступности, `SEO-оптимизации` и общего качества веб-страниц.

Существует несколько способов установить `HTMLHint`. Один из самых простых - использовать пакетный менеджер `npm`:

```bash
npm install htmlhint --save-dev
```

Эта команда установит `HTMLHint` в ваш проект как зависимость разработки.

Файл конфигурации для `HTMLHint`:

```json
// .htmlhintrc.json
{
  "tag-pair": true,
  "doctype-first": false,
  "id-unique": true,
  "attr-lowercase": true,
  "attr-value-double-quotes": true,
  "doctype-html5": true,
  "tagname-lowercase": true,
  "attr-no-duplication": true,
  "spec-char-escape": true,
  "id-class-value": "underline",
  "style-disabled": true
}
```

1. `tag-pair`: Указывает, что каждый открывающий тег должен иметь соответствующий ему закрывающий тег.

2. `doctype-first`: Указывает, что объявление `DOCTYPE` должно быть первым элементом в документе.

3. `id-unique`: Проверяет, что значение атрибута `id` уникально в пределах документа.

4. `attr-lowercase`: Указывает, что все имена атрибутов должны быть написаны в нижнем регистре.

5. `attr-value-double-quotes`: Требует, чтобы значения атрибутов были заключены в двойные кавычки.

6. `doctype-html5`: Проверяет, что `DOCTYPE` соответствует `HTML5` стандарту.

7. `tagname-lowercase`: Указывает, что все названия тегов должны быть в нижнем регистре.

8. `attr-no-duplication`: Проверяет, что каждый атрибут в теге уникален.

9. `spec-char-escape`: Требует, чтобы специальные символы в текстовых узлах были корректно экранированы.

10. `id-class-value`: Указывает, какой стиль использовать для значений `id` и `class`. Здесь указано `"underline"`, что, вероятно, означает, что подчеркивание используется в качестве разделителя.

11. `style-disabled`: Запрещает использование атрибута `style`.

Эти настройки представляют собой набор правил, которые `HTMLHint` будет применять при проверке `HTML-кода`. Использование подобных инструментов помогает поддерживать чистоту и корректность вашего `HTML-кода`.

### 6. lint-staged

[lint-staged](https://www.npmjs.com/package/lint-staged) - это инструмент, который предназначен для запуска линтеров (например, `ESLint`, `Stylelint`) только для тех файлов, которые включены в коммит.

Вот краткая информация о `lint-staged`:

1. **Фокус на файлы в коммите**: `lint-staged` проверяет только те файлы, которые входят в состав коммита. Это позволяет обеспечить соответствие кода заданным стандартам перед отправкой его в репозиторий.

2. **Конфигурация в `package.json`**: `lint-staged` конфигурируется в разделе `lint-staged` файла `package.json`. В этом разделе указываются команды и паттерны файлов, для которых нужно запустить линтер.

3. **Интеграция с `git` и `pre-commit` хуками**: `lint-staged` часто используется с `git` `pre-commit` хуком. Это позволяет автоматически запускать проверки перед каждым коммитом.

4. **Параллельное выполнение команд**: `lint-staged` может выполнять несколько команд параллельно, что ускоряет процесс проверки.

5. **Интерактивный режим**: `lint-staged` может запускаться в интерактивном режиме, позволяя пользователю выбирать, какие файлы включить в коммит.

6. Поддержка различных линтеров: `lint-staged` поддерживает множество различных линтеров и инструментов для статического анализа кода.

Использование `lint-staged` помогает обеспечить соблюдение стандартов кодирования и качества перед отправкой изменений в репозиторий. Это особенно важно в командной разработке, где необходимо поддерживать единый стиль кодирования.

Существует несколько способов установить `lint-staged`. Один из самых простых - использовать пакетный менеджер `npm`:

```bash
npm install lint-staged --save-dev
```

Эта команда установит `lint-staged` в ваш проект как зависимость разработки.

Файл конфигурации для `lint-staged`:

```json
// package.json
{
  // ...
  "lint-staged": {
    "*.{js,jsx}": "eslint --fix",
    "*.{css,scss}": [
      "prettier --write",
      "stylelint --fix --custom-syntax postcss-scss"
    ],
    "*.{json,md}": "prettier --write",
    "*.html": ["prettier --write", "htmlhint"]
  }
  // ...
}
```

1. `"*.{js,jsx}": "eslint --fix"`: Для всех файлов с расширениями `.js` и `.jsx`, перед коммитом будет запускаться `ESLint` с опцией `--fix`, что позволяет автоматически исправлять простые проблемы в коде.

2. `"*.{css,scss}": ["prettier --write", "stylelint --fix --custom-syntax postcss-scss"]`: Для всех файлов с расширениями `.css` и `.scss`, перед коммитом сначала запускается `Prettier` для автоматического исправления форматирования, а затем `Stylelint` с флагом `--fix` и кастомным синтаксисом `postcss-scss`.

3. `"*.{json,md}": "prettier --write"`: Для всех файлов с расширениями `.json` и `.md`, перед коммитом будет запускаться `Prettier` для автоматического исправления форматирования.

4. `"*.html": ["prettier --write", "htmlhint"]`: Для всех файлов с расширением `.html`, перед коммитом сначала запускается `Prettier` для автоматического исправления форматирования, а затем запускается `HTMLHint` для проверки на наличие ошибок.

Эти настройки позволяют автоматизировать процесс проверки и исправления кода перед каждым коммитом, что помогает поддерживать высокое качество кода в проекте.

### 7. Commitlint

[Commitlint](https://commitlint.js.org/) - это инструмент для проверки сообщений коммитов на соответствие определенным стандартам. Он позволяет поддерживать структурированный и читаемый формат сообщений коммитов в проекте.

Вот краткая информация о `Commitlint`:

1. **Установка `Commitlint`**:

```bash
npm install --save-dev @commitlint/{config-conventional,cli}
```

Эта команда устанавливает `Commitlint` и стандартные конфигурации для работы с конвенциональными коммитами.

2. **Настройка конфигурации**:

В файле `package.json` или в отдельном конфигурационном файле создается секция с правилами для сообщений коммитов. Пример:

```js
// commitlint.config.js
module.exports = {
  extends: ["@commitlint/config-conventional"],
  rules: {
    "body-max-line-length": [0, "always", Infinity],
  },
};
```

1. `module.exports = {`: эта строка начинает экспорт объекта конфигурации из модуля `Node.js`.

2. `extends: ['@commitlint/config-conventional'],`: здесь устанавливается расширение правил, используемых для проверки сообщений коммитов. В данном случае используется стандартная конфигурация `@commitlint/config-conventional`, которая включает базовые правила для конвенциональных коммитов.

3. `rules: {`: этот блок позволяет переопределить или добавить дополнительные правила для проверки сообщений коммитов.

4. `'body-max-line-length': [0, 'always', Infinity]`: это правило указывает максимальную длину строки для тела (`body`) сообщения коммита. Здесь используются следующие значения:

   - `0`: Правило отключено.
   - `'always'`: Проверка должна быть выполнена всегда.
   - `Infinity`: Максимальная длина строки не ограничена.

В данном случае, это означает, что проверка максимальной длины строки в теле сообщения отключена.

3. **Использование в хуках `Git`**: `Commitlint` может быть использован в `Git-хуках` (например, `commit-msg`) для автоматической проверки сообщений коммитов перед отправкой их в репозиторий.

4. **Стандартные конвенции**: `Commitlint` поддерживает стандартные конвенции для сообщений коммитов, такие как `feat`, `fix`, `chore`, `docs`, и другие. Эти конвенции помогают структурировать сообщения и быстро понимать изменения в коде.

5. **Пользовательские конвенции**: вы можете создать свои собственные правила и шаблоны для сообщений коммитов, если стандартные конвенции не подходят под ваш проект.

6. **Интеграция с CI/CD**: `Commitlint` может быть интегрирован с процессами непрерывной интеграции и доставки (`CI/CD`) для автоматической проверки сообщений коммитов в пайплайнах.

Использование `Commitlint` помогает поддерживать чистоту и структуру истории коммитов, что улучшает читаемость и управляемость проекта.

### 8. Husky

[Husky](https://typicode.github.io/husky/getting-started.html) - это инструмент для управления `Git-хуками` (`Git hooks`). `Хуки Git` - это сценарии, которые автоматически запускаются в определенные моменты событий в процессе работы с `Git`. `Husky` позволяет легко настраивать и управлять этими хуками.

Вот краткая информация о `Husky`:

1. **Установка `Husky`**:

```bash
npm install husky --save-dev
```

Эта команда устанавливает `Husky` как зависимость разработки в вашем проекте.

2. **Инициализация `Husky`**:

```bash
npx husky install
```

Эта команда инициализирует `Husky` в вашем проекте.

3. **Добавление `Git-хуков`**:

```bash
# .husky/commit-msg

#!/bin/sh
npx commitlint --edit $1
```

Этот скрипт предназначен для использования в `Git-хуках` с помощью инструмента `Husky`. Он представляет собой скрипт, который будет запускаться перед каждым коммитом и проверять сообщение коммита с использованием инструмента `Commitlint`.

`npx commitlint --edit $1`:

- `npx commitlint` - Здесь `npx` используется для запуска команды `commitlint`, который должен быть установлен глобально или локально в проекте.

- `--edit` - Этот флаг говорит `commitlint` о том, что нужно проверить сообщение коммита.

- `$1` - Это аргумент, который будет передан скрипту. В этом контексте, это путь к временному файлу, в котором содержится сообщение коммита.

Таким образом, при каждой попытке коммита, этот скрипт будет вызываться, и `commitlint` будет проверять сообщение коммита на соответствие определенным стандартам. Если сообщение не соответствует стандартам, коммит будет отклонен.

```bash
# .husky/pre-commit

#!/bin/sh
npx lint-staged
```

Этот скрипт предназначен для использования в `Git-хуках` с помощью инструмента `Husky`. Он будет запускаться перед каждым коммитом и запускать команду `lint-staged`.

Вот пошаговое разъяснение:

`npx lint-staged`:

- `npx` - Эта команда позволяет запускать пакеты, установленные локально в проекте, без необходимости устанавливать их глобально.

- `lint-staged` - Это команда, которая будет запущена. `lint-staged` предназначен для автоматизации проверки кода перед коммитом.

`lint-staged` может быть настроен в `package.json` и запускать различные инструменты линтинга (например, `ESLint`, `Prettier`, `Stylelint`) на измененных файлах перед коммитом.

Таким образом, при каждой попытке коммита, этот скрипт будет вызываться, и `lint-staged` будет запускать проверку кода на соответствие установленным стандартам. Если какие-то файлы не соответствуют стандартам, коммит будет отклонен.

4. **Конфигурация `Git-хуков`**: конфигурация `Git-хуков` хранится в директории `.husky` в вашем проекте.

5. **Управление хуками**: вы можете добавить, удалить или изменить хуки в директории `.husky` вручную.

6. **Запуск скриптов перед коммитом**: `Husky` позволяет вам автоматизировать процессы перед каждым коммитом. Например, вы можете запустить линтеры для проверки кода перед отправкой его в репозиторий.

Использование `Husky` помогает поддерживать качество кода и предотвращать коммиты с ошибками или несоответствиями стандартам.

### 9. Babel

[Babel](https://babeljs.io/) - это инструмент, который позволяет переводить современный `JavaScript` (`ES6+`), который может не поддерживаться всеми браузерами, в старый синтаксис (`ES5`), который более устойчиво работает в различных окружениях.

Вот несколько причин, почему разработчики используют `Babel`:

1. **Обратная совместимость**: Старые версии браузеров не поддерживают все новые возможности `JavaScript`. `Babel` позволяет разработчикам писать код, используя самые новые фичи, и транспилировать его в синтаксис, понимаемый старыми браузерами.

2. **Использование новых возможностей**: Разработчики могут использовать новые функции и синтаксис, предложенные последними стандартами `ECMAScript`, не дожидаясь, пока все браузеры полностью поддержат эти изменения.

3. **Модульность**: `Babel` позволяет использовать модульную систему, например, `import/export`, даже если она не поддерживается в текущем окружении.

4. **Экосистема инструментов**: Многие современные инструменты разработки `JavaScript`, такие как `Webpack`, используют `Babel` как часть своего процесса сборки.

5. **Поддержка React и JSX**: `Babel` позволяет использовать `JSX`, расширение синтаксиса `JavaScript`, для более удобной разработки интерфейсов в `React`.

6. **Эксперименты и новаторство**: Разработчики могут экспериментировать с новыми идеями и возможностями, не ожидая, пока они будут широко поддерживаться в браузерах.

В целом, `Babel` предоставляет мощный инструмент для поддержания современной разработки `JavaScript` и обеспечивает, что ваш код будет работать в различных средах и браузерах.

Существует несколько способов установить `Babel`. Один из самых простых - использовать пакетный менеджер `npm`:

```bash
npm install @babel/core @babel/preset-env --save-dev
```

Эта команда установит `Babel` в ваш проект как зависимость разработки.

Файл конфигурации для `Babel`:

```js
// babel.config.js
const presets = [
  [
    "@babel/preset-env",
    {
      targets: {
        edge: "17",
        ie: "11",
        firefox: "50",
        chrome: "64",
        safari: "11.1",
      },

      useBuiltIns: "entry",
    },
  ],
];

module.exports = { presets };
```

1. `const presets = [ ... ]`: в этом блоке определяются наборы правил (`presets`) для транспиляции кода.

2. `'@babel/preset-env'`: используется набор правил `@babel/preset-env`, который позволяет `Babel` адаптировать транспиляцию под текущее окружение.

3. `targets: { ... }`: здесь указываются целевые браузеры, для которых производится транспиляция кода. Например, код будет транспилирован так, чтобы он работал в `Microsoft Edge 17`, `Internet Explorer 11`, `Firefox 50`, `Chrome 64`, `Safari 11.1` и более новых версиях этих браузеров.

4. `useBuiltIns: 'entry'`: этот параметр сообщает `Babel` включить полифиллы (`polyfills`) для тех функций, которые не поддерживаются в целевых браузерах. Опция entry означает, что `Babel` будет автоматически добавлять необходимые полифиллы в ваш код.

5. `module.exports = { presets };`: эта строка экспортирует настройки `Babel` из этого файла.

Используя эту конфигурацию, `Babel` будет транспилировать ваш код так, чтобы он был совместим с указанными браузерами и включал необходимые полифиллы.

## Авторы

[Ильяс Сибгатуллин](https://github.com/BJuice1984): [i.sibgatullin59@gmail.com](i.sibgatullin59@gmail.com)

[Даниил Рябов](https://github.com/NotACat1): [notacat.mail@gmail.com](notacat.mail@gmail.com)

[Виктор Воронков](https://github.com/VictorV77): [Victorv1986@yandex.ru](Victorv1986@yandex.ru)

[Анна Кособуцкая](https://github.com/akosobutskaya): [akosobutskaya@yandex.ru](akosobutskaya@yandex.ru)

[Екатерина Яковлева](https://github.com/llanaba): [regspamm@yandex.ru](regspamm@yandex.ru)

[Андрей Ланцов](https://github.com/Raido13): [andreyonohin88@gmail.com](andreyonohin88@gmail.com)

[Богдан Тимощук](https://github.com/bogdaryan): [bogdan10050@gmail.com](bogdan10050@gmail.com)

[Светлана Подсобляева](https://github.com/Sapodsoblyaeva): [sa.podsoblyaeva@gmail.com](sa.podsoblyaeva@gmail.com)
